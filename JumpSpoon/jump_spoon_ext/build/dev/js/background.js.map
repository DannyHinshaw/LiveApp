{"version":3,"sources":["webpack:///webpack/bootstrap 5b9d7cc06709b841eb46","webpack:///./src/js/background.js"],"names":["console","log","HEADERS_TO_STRIP_LOWERCASE","chrome","webRequest","onHeadersReceived","addListener","details","responseHeaders","filter","header","indexOf","name","toLowerCase","urls"],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AC7DA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAA,QAAQC,GAAR,CAAY,0BAAZ,E,CAAyC;;AAEzC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA,IAAMC,6BAA6B,CACjC,yBADiC,EAEjC,iBAFiC,EAGjC,kBAHiC,CAAnC;;AAMA;AACAC,OAAOC,UAAP,CAAkBC,iBAAlB,CAAoCC,WAApC,CAAgD,UAACC,OAAD,EAAa;AAAE;AAC7D,SAAO;AACLC,qBAAiBD,QAAQC,eAAR,CAAwBC,MAAxB,CAA+B,UAACC,MAAD,EAAY;AAAE;AAC5D,aAAOR,2BAA2BS,OAA3B,CAAmCD,OAAOE,IAAP,CAAYC,WAAZ,EAAnC,IAAgE,CAAvE;AACD,KAFgB;AADZ,GAAP;AAKD,CAND,EAMG,EAAEC,MAAM,CAAC,YAAD,CAAR,EANH,EAM6B,CAAC,UAAD,EAAa,iBAAb,CAN7B,E","file":"./js/background.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 85);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5b9d7cc06709b841eb46","/* eslint-env webextensions */\n/*\nimport handlers from './modules/handlers';\nimport msg from './modules/msg';\n*/\n\n// here we use SHARED message handlers, so all the contexts support the same\n// commands. in background, we extend the handlers with two special\n// notification hooks. but this is NOT typical messaging system usage, since\n// you usually want each context to handle different commands. for this you\n// don't need handlers factory as used below. simply create individual\n// `handlers` object for each context and pass it to msg.init() call. in case\n// you don't need the context to support any commands, but want the context to\n// cooperate with the rest of the extension via messaging system (you want to\n// know when new instance of given context is created / destroyed, or you want\n// to be able to issue command requests from this context), you may simply\n// omit the `hadnlers` parameter for good when invoking msg.init()\n\nconsole.log('BACKGROUND SCRIPT WORKS!'); // eslint-disable-line no-console\n\n/**\n *  DEMO FOR MESSENGER\n/*\n// adding special background notification handlers onConnect / onDisconnect\nfunction logEvent(ev, context, tabId) {\n  console.log(`${ev}: context = ${context}, tabId = ${tabId}`); // eslint-disable-line no-console\n}\nhandlers.onConnect = logEvent.bind(null, 'onConnect');\nhandlers.onDisconnect = logEvent.bind(null, 'onDisconnect');\nconst message = msg.init('bg', handlers.create('bg'));\n\n// issue `echo` command in 10 seconds after invoked,\n// schedule next run in 5 minutes\nfunction helloWorld() {\n  console.log( // eslint-disable-line no-console\n  '===== will broadcast \"hello world!\" in 10 seconds');\n    setTimeout(() => {\n    console.log('>>>>> broadcasting \"hello world!\" now'); // eslint-disable-line no-console\n    message.bcast('echo', 'hello world!', () =>\n      console.log('<<<<< broadcasting done') // eslint-disable-line no-console\n    );\n  }, 10 * 1000);\n  setTimeout(helloWorld, 5 * 60 * 1000);\n}\n\n// start broadcasting loop\nhelloWorld();\n*/\n\nconst HEADERS_TO_STRIP_LOWERCASE = [\n  'content-security-policy',\n  'x-frame-options',\n  'x-xss-protection'\n];\n\n// CORS Support for iframes and XHR's\nchrome.webRequest.onHeadersReceived.addListener((details) => { // eslint-disable-line arrow-body-style, max-len\n  return {\n    responseHeaders: details.responseHeaders.filter((header) => { // eslint-disable-line arrow-body-style, max-len\n      return HEADERS_TO_STRIP_LOWERCASE.indexOf(header.name.toLowerCase()) < 0;\n    })\n  };\n}, { urls: ['<all_urls>'] }, ['blocking', 'responseHeaders']);\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/background.js"],"sourceRoot":""}